<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[<三每/>]]></title>
  <link href="http://viczy.github.io/atom.xml" rel="self"/>
  <link href="http://viczy.github.io/"/>
  <updated>2015-03-11T08:35:50+08:00</updated>
  <id>http://viczy.github.io/</id>
  <author>
    <name><![CDATA[vic]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[App-Extension-iOS]]></title>
    <link href="http://viczy.github.io/blog/2015/03/11/app-extension-ios/"/>
    <updated>2015-03-11T08:28:44+08:00</updated>
    <id>http://viczy.github.io/blog/2015/03/11/app-extension-ios</id>
    <content type="html"><![CDATA[<h2>Extension环境</h2>

<ul>
<li>iOS8+</li>
</ul>


<h2>Extension概述</h2>

<p>Extension让app之间的数据交互成为可能。用户可以在app中使用其他应用提供的功能，而无需离开当前的应用。</p>

<p>在iOS 8系统之前，每一个app在物理上都是彼此独立的，app之间不能互访彼此的私有数据。</p>

<p>而在引入扩展之后，其他app可以与扩展进行数据交换。基于安全和性能的考虑，每一个扩展运行在一个单独的进程中，它拥有自己的bundle， bundle后缀名是.appex。</p>

<p>iOS 8系统有6个支持扩展的系统区域，分别是Today、Share、Action、Photo Editing、Storage Provider、Custom keyboard。支持扩展的系统区域也被称为扩展点。</p>

<h2>Extension的生命周期</h2>

<p><img src="images/App-Extensions-iOS/app_extensions_lifecycle.png" alt="lifecyle" /></p>

<p>extension的开始于用户通过host-app点击extension,<code>系统</code>启动Extension；终止于用户取消任务，或者任务执行结束，或者开启了一个长时后台任务时，系统会将其杀掉。</p>

<h2>Extension的通信</h2>

<p><img src="images/App-Extensions-iOS/simple_communication.png" alt="communication" /></p>

<p>extension与host-app直接通信，而host-app与containing-app之间绝对不会通信。extension与containing不会通信但可以数据共享。如下图：
<img src="images/App-Extensions-iOS/communication.png" alt="Mou icon" /></p>

<p>extension和containing-app可以共同读写一个被称为Shared resources的存储区域，这是通过App Groups实现。</p>

<p>最终host-app，extension，containing-app的三者关系如下图：</p>

<p><img src="images/App-Extensions-iOS/detailed_communication.png" alt="detail" /></p>

<h2>Extension类型</h2>

<h3>Today Extension</h3>

<p>通常被成为”组件”,Today Extension出现在通知中心的今日视点。这些小视图控制器包含着信息片段让用户一目了然。我们已经看到过苹果自带股票和天气等小”组件”(Widget)的形式。</p>

<p><img src="images/App-Extensions-iOS/today.png" alt="detail" /></p>

<h3>Share Extension</h3>

<p>在iOS 8之前，用户只有Facebook,Twitter等有限的几个分享选项可以选择。如果希望将内容分享到Pinterest，开发者则需要一些额外的努力。在iOS 8中，开发者可以创建自定义的分享选项。</p>

<p><img src="images/App-Extensions-iOS/share.png" alt="detail" /></p>

<h3>Action Extension</h3>

<p>action在所有支持的扩展点中扩展性最强的一个。它可以实现转换另一个app上下文中的内容。苹果在WWDC大会上演示了一个Bing翻译动作扩展，它可以将在Safari中选中的文本翻译成不同的语言。</p>

<p><img src="images/App-Extensions-iOS/action.png" alt="detail" /></p>

<h3>Photo Editing Extension</h3>

<p>在iOS 8之前，如果你想为你的照片添加一个特殊的滤镜，你需要进入第三方app中，这个过程是相当繁琐的。在iOS 8中，你可以直接在Photos中使用第三方app，如Instagram，VSCO cam、Aviary提供的Photo Editing扩展完成对图片的编辑，而无需离开当前的app。</p>

<p><img src="images/App-Extensions-iOS/photo.png" alt="detail" /></p>

<h3>Document Provider Extension</h3>

<p>Storage Provider让跨多个文件存储服务之间的管理变得更简单。类似Dropbox、Google Drive等存储提供商通过在iOS 8中提供一个Storage Provider扩展，app直接可以使用这些扩展检索和存储文件而不再需要创建不必要的拷贝。</p>

<p><img src="images/App-Extensions-iOS/photo.png" alt="detail" /></p>

<h3>Custom Keyboard Extension</h3>

<p>苹果公司在2007年率先推出了触摸屏键盘，但一直没多大改进。在这一方面，Android则将键盘权限开放给了第三方开发者，所以出现了许多像Swype，SwiftKey,搜狗等优秀的键盘输入法。在iOS 8中，苹果终于将键盘权限开发给了第三方开发者，自定义键盘输入法可以让用户在整个系统范围内使用。</p>

<p><img src="images/App-Extensions-iOS/keyboard.png" alt="detail" /></p>

<h2>拓展</h2>

<p>更多信息请关注苹果官方文档：<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ExtensibilityPG/ExtensibilityPG.pdf">ExtensibilityPG</a></p>

<h4>参考资料</h4>

<ul>
<li><a href="http://www.devtalking.com/articles/understand-how-an-extension-works/">http://www.devtalking.com/articles/understand-how-an-extension-works/</a></li>
<li><a href="http://www.cocoachina.com/ios/20140721/9205.html">http://www.cocoachina.com/ios/20140721/9205.html</a></li>
<li><a href="https://github.com/ipader/SwiftGuide">https://github.com/ipader/SwiftGuide</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu+nginx+passenger]]></title>
    <link href="http://viczy.github.io/blog/2015/03/08/ubuntu-plus-nginx-plus-passenger/"/>
    <updated>2015-03-08T12:15:08+08:00</updated>
    <id>http://viczy.github.io/blog/2015/03/08/ubuntu-plus-nginx-plus-passenger</id>
    <content type="html"><![CDATA[<h2>Ubuntu</h2>

<p>通过<code>chef-solo</code>配置好某个Ubuntu server系统，然后通过<code>Vagrant</code>启动并登陆该server系统。升级该系统软件，并安装一些组件。</p>

<h4>系统升级</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo apt-get update</span></code></pre></td></tr></table></div></figure>


<h4>安装组件</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo apt-get install build-essential zlib1g-dev libssl-dev libreadline-dev libyaml-dev libcurl4-openssl-dev curl git-core python-software-properties libsqlite3-0 libsqlite3-dev sqlite3</span></code></pre></td></tr></table></div></figure>


<h4>安装PostgreSQL</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo apt-get install postgresql postgresql-contrib libpq-dev</span></code></pre></td></tr></table></div></figure>


<h4>安装ruby</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ \curl -L https://get.rvm.io | bash -s stable --ruby</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rvm install 2.1.2
</span><span class='line'>$ rvm 2.1.2 --default</span></code></pre></td></tr></table></div></figure>


<h4>安装rails</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem install rails</span></code></pre></td></tr></table></div></figure>


<h2>Nginx+Passenger</h2>

<h4>安装passenger</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem install passenger</span></code></pre></td></tr></table></div></figure>


<h5>安装nginx</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rvmsudo passenger-install-nginx-module</span></code></pre></td></tr></table></div></figure>


<h4>安装nginx脚本</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gpg --keyserver keyserver.ubuntu.com --recv-keys 561F9B9CAC40B2F7</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gpg --armor --export 561F9B9CAC40B2F7 | sudo apt-key add -</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo apt-get install apt-transport-https</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo sh -c "echo 'deb https://oss-binaries.phusionpassenger.com/apt/passenger trusty main' &gt;&gt; /etc/apt/sources.list.d/passenger.list"</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo chown root: /etc/apt/sources.list.d/passenger.list</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo chmod 600 /etc/apt/sources.list.d/passenger.list</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo apt-get update</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo apt-get install nginx-full passenger</span></code></pre></td></tr></table></div></figure>


<p><code>/etc/nginx/sites-enabled/default</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo vi /etc/nginx/sites-enabled/default</span></code></pre></td></tr></table></div></figure>


<pre><code>server {
    listen 80 default;
    server_name vicspdemo.com; # 这里填写你真实域名
    root /home/vagrant/apps/spdemo/current/public;# 这里填写你的web启动位置
    passenger_enabled on;
}
</code></pre>

<p><code>/etc/nginx/nginx.conf</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo vi /etc/nginx/nginx.conf</span></code></pre></td></tr></table></div></figure>


<pre><code>##
# Phusion Passenger config
##
# Uncomment it if you installed passenger or passenger-enterprise
##
passenger_root /usr/lib/ruby/vendor_ruby/phusion_passenger/locations.ini;
passenger_ruby /home/vagrant/.rvm/wrappers/default/ruby;
# passenger_root /usr/lib/ruby/vendor_ruby/phusion_passenger/locations.ini;
# passenger_ruby /usr/bin/ruby;
</code></pre>

<h4>参考资料</h4>

<ul>
<li><a href="https://ruby-china.org/topics/12967">https://ruby-china.org/topics/12967</a></li>
<li><a href="https://ruby-china.org/wiki/mac-nginx-passenger-rails">https://ruby-china.org/wiki/mac-nginx-passenger-rails</a></li>
<li><a href="https://gorails.com/deploy/ubuntu/14.04">https://gorails.com/deploy/ubuntu/14.04</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant]]></title>
    <link href="http://viczy.github.io/blog/2015/03/08/vagrant/"/>
    <updated>2015-03-08T12:14:58+08:00</updated>
    <id>http://viczy.github.io/blog/2015/03/08/vagrant</id>
    <content type="html"><![CDATA[<p>Vagrant就是为了方便的实现虚拟化环境而设计的，使用Ruby开发，基于VirtualBox等虚拟机管理软件的接口，提供了一个可配置、轻量级的便携式虚拟开发环境。使用Vagrant可以很方便的就建立起来一个虚拟环境，而且可以模拟多台虚拟机，这样我们平时还可以在开发机模拟分布式系统。</p>

<p>Vagrant还会创建一些共享文件夹，用来给你在主机和虚拟机之间共享代码用。这样就使得我们可以在主机上写程序，然后在虚拟机中运行。如此一来团队之间就可以共享相同的开发环境。</p>

<h2>环境</h2>

<p>Vagrant背后用的是Virtual Box作为虚拟机（<a href="https://www.virtualbox.org/wiki/Downloads">Virtual Box下载地址</a>），Vagrant可以在<a href="http://www.vagrantup.com/">Vagrant官网</a>下载打包好的版本。在学习下面内容前配置好环境，安装Vitrual Box，Vagrant。</p>

<h2>配置作业系统</h2>

<p>在配置作业系统前，先建立xxx（系统用户名）的开发环境目录</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir /Users/xxx/vagrant</span></code></pre></td></tr></table></div></figure>


<p>每个打包好的作业系统在Vagrant称之为Box，作业系统我们在<a href="http://www.vagrantbox.es/">vagrantbox</a>上可以获取。我们选择列表中的<code>Ubuntu Server Precise 14.04 amd64</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vagrant box add Ubuntu-Server-Precise-14.04-amd64 {https://oss-binaries.phusionpassenger.com/vagrant/boxes/latest/ubuntu-14.04-amd64-vbox.box}</span></code></pre></td></tr></table></div></figure>


<p>Vagrant将会下载链接的镜像文件，下载好的镜像文件放在<code>/Users/xxx/.vagrant.d/boxes/</code>目录下。</p>

<p>查看Vagrant的box列表</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vagrant box list</span></code></pre></td></tr></table></div></figure>


<h2>初始化作业系统</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vagrant init Ubuntu-Server-Precise-14.04-amd64</span></code></pre></td></tr></table></div></figure>


<p>命令运行结束后将在<code>/Users/xxx/vagrant/</code>目录下生成一个<code>Vagrantfile</code>文件，该文件是box的配置文件。</p>

<pre><code># -*- mode: ruby -*-
# vi: set ft=ruby :
VAGRANTFILE_API_VERSION = "2"
Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.vm.box = "Ubuntu-Server-Precise-14.04-amd64"
  config.vm.network "forwarded_port", guest: 80, host: 8080
  config.vm.network "private_network", ip: "192.168.33.10"
end
</code></pre>

<p>销毁初始化的资源</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vagrant destroy</span></code></pre></td></tr></table></div></figure>


<h2>运行VM</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vagrant up</span></code></pre></td></tr></table></div></figure>


<p>关闭运行的VM</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vagrant halt</span></code></pre></td></tr></table></div></figure>


<h2>SSH连接到VM</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vagrant ssh</span></code></pre></td></tr></table></div></figure>


<p>登陆的是预设用户<code>vagrant</code>，密码是<code>vagrant</code>。</p>

<p>登出的话只需在vm中输入shell命令<code>exit</code>,即可登出，关闭的话在vm中输入shell命令<code>poweroff</code>，当让也可以采用上面在正常环境输入<code>vagrant halt</code>关闭。</p>

<h4>官方网站</h4>

<p><a href="https://www.vagrantup.com/">https://www.vagrantup.com/</a></p>

<h4>Github</h4>

<p><a href="https://github.com/mitchellh/vagrant">https://github.com/mitchellh/vagrant</a></p>

<h4>参考资料</h4>

<ul>
<li><a href="http://gogojimmy.net/2013/05/26/vagrant-tutorial/">http://gogojimmy.net/2013/05/26/vagrant-tutorial/</a></li>
<li><a href="https://github.com/astaxie/Go-in-Action/blob/master/ebook/zh/preface.md">https://github.com/astaxie/Go-in-Action/blob/master/ebook/zh/preface.md</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP/IP协议]]></title>
    <link href="http://viczy.github.io/blog/2015/03/08/tcp-slash-ipxie-yi/"/>
    <updated>2015-03-08T10:51:54+08:00</updated>
    <id>http://viczy.github.io/blog/2015/03/08/tcp-slash-ipxie-yi</id>
    <content type="html"><![CDATA[<h2>OSI</h2>

<table>
<thead>
<tr>
<th style="text-align:left;">层                    </th>
<th style="text-align:center;">  数据格式                  </th>
<th style="text-align:center;">  典型设备</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">应用层(Application)    </td>
<td style="text-align:center;">                           </td>
<td></td>
</tr>
<tr>
<td style="text-align:left;">表现层(Presentation)   </td>
<td style="text-align:center;">                           </td>
<td></td>
</tr>
<tr>
<td style="text-align:left;">会话层(Session)        </td>
<td style="text-align:center;">                           </td>
<td></td>
</tr>
<tr>
<td style="text-align:left;">传输层(Transport)      </td>
<td style="text-align:center;"> 组成数据段(Segment)        </td>
<td></td>
</tr>
<tr>
<td style="text-align:left;">网络层(Network)        </td>
<td style="text-align:center;"> 分割组成数据包(Packet)      </td>
<td style="text-align:center;">  路由器</td>
</tr>
<tr>
<td style="text-align:left;">数据链路层(DataLink)   </td>
<td style="text-align:center;">  比特信息封装成数据帧(Frame)  </td>
<td style="text-align:center;">  网桥，网卡，交换机</td>
</tr>
<tr>
<td style="text-align:left;">物理层(Physical)       </td>
<td style="text-align:center;"> 传输比特流(bit)             </td>
<td style="text-align:center;">  中继器，集线器，线缆与光纤</td>
</tr>
</tbody>
</table>


<p><br /></p>

<table>
<thead>
<tr>
<th style="text-align:left;">TCP/IP </th>
<th style="text-align:center;"> OSI                 </th>
<th style="text-align:center;"> 相关协议与标准</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">应用层  </td>
<td style="text-align:center;"> 应用层，表现层，会话层 </td>
<td style="text-align:center;">  HTTP,FTP,SMTP,POP3,NFS,SSH</td>
</tr>
<tr>
<td style="text-align:left;">传送层  </td>
<td style="text-align:center;"> 传送层               </td>
<td style="text-align:center;"> TCP,UDP</td>
</tr>
<tr>
<td style="text-align:left;">网络层  </td>
<td style="text-align:center;"> 网络层               </td>
<td style="text-align:center;"> IP,ICMP</td>
</tr>
<tr>
<td style="text-align:left;">链接层  </td>
<td style="text-align:center;"> 链路层，物理层        </td>
<td style="text-align:center;"> LAN,ARP,WAN</td>
</tr>
</tbody>
</table>


<p><br /></p>

<h4>应用层</h4>

<p>网络服务与使用者应用程序间的一个借口</p>

<h4>表现层</h4>

<p>数据表示，数据安全，数据压缩</p>

<h4>会话层</h4>

<p>建立，管理和终止会话</p>

<h4>传送层</h4>

<p>用一个寻址机制来标识一个特定的应用程序</p>

<h4>网络层</h4>

<p>基于网络层地址（ip地址）进行不同网络系统间的路径选择</p>

<h4>链接层</h4>

<p>在物理层上建立，撤销，标识逻辑链接和链接复用以及差错校验等功能。通过使用接受系统的硬件地址或物理地址来寻址</p>

<h4>物理层</h4>

<p>建立，维护和取消物理连接</p>

<h2>ARP</h2>

<p>地址解析协议（Address Resolution Protocol），其基本功能为通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。它是IPv4中网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。</p>

<h4>ARP报文格式</h4>

<table>
<thead>
<tr>
<th style="text-align:left;">0                </th>
<th style="text-align:right;"> 7                                </th>
<th style="text-align:left;"> 15                 </th>
<th style="text-align:right;"> 31</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:right;"> 硬件类型(Hardware Type)           </td>
<td style="text-align:left;">                    </td>
<td style="text-align:right;"> 协议类型(Protocol Type)</td>
</tr>
<tr>
<td style="text-align:left;">硬件长度地址(HLEN) </td>
<td style="text-align:right;"> 协议长度(PLEN)                    </td>
<td style="text-align:left;">                    </td>
<td style="text-align:right;"> 操作类型(Operation)</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:right;">                                  </td>
<td style="text-align:left;">                    </td>
<td style="text-align:right;"> 发送方硬件地址(Sender HA(Byte0~3))</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:right;"> 发送方硬件地址(Sender HA(Byte0~3)) </td>
<td style="text-align:left;">                    </td>
<td style="text-align:right;"> 发送方ip地址(Sender IP(Byte0~1))</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:right;"> 发送方ip地址(Sender IP(Byte2~3))   </td>
<td style="text-align:left;">                    </td>
<td style="text-align:right;"> 接收方硬件地址(Target HA(Byte0~1))</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:right;">                                  </td>
<td style="text-align:left;">                    </td>
<td style="text-align:right;"> 接受方硬件地址(Target HA(Byte2~5))</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:right;">                                  </td>
<td style="text-align:left;">                    </td>
<td style="text-align:right;"> 接收方ip地址(Target HA(Byte0~3))</td>
</tr>
</tbody>
</table>


<p><br /></p>

<h5>硬件类型</h5>

<p>指明了发送方想知道的硬件接口类型，以太网的值为1；</p>

<h5>协议类型</h5>

<p>指明了发送方提供的高层协议类型，IP为0800（16进制）；</p>

<h5>硬件地址长度和协议长度</h5>

<p>指明了硬件地址和高层协议地址的长度，这样ARP报文就可以在任意硬件和任意协议的网络中使用；</p>

<h5>操作类型</h5>

<p>用来表示这个报文的类型，ARP请求为1，ARP响应为2，RARP请求为3，RARP响应为4；</p>

<h5>发送方硬件地址（0-3字节）</h5>

<p>源主机硬件地址的前3个字节；</p>

<h5>发送方硬件地址（4-5字节）</h5>

<p>源主机硬件地址的后3个字节；</p>

<h5>发送方IP地址（0-1字节）</h5>

<p>源主机硬件地址的前2个字节；</p>

<h5>发送方IP地址（2-3字节）</h5>

<p>源主机硬件地址的后2个字节；</p>

<h5>目标硬件地址（0-1字节）</h5>

<p>目的主机硬件地址的前2个字节；</p>

<h5>目标硬件地址（2-5字节）</h5>

<p>目的主机硬件地址的后4个字节；</p>

<h5>目标IP地址（0-3字节）</h5>

<p>目的主机的IP地址。</p>

<h2>TCP</h2>

<p>传输控制协议（英语：Transmission Control Protocol, TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。</p>

<h4>TCP报文格式</h4>

<table>
<thead>
<tr>
<th style="text-align:left;">偏移     </th>
<th style="text-align:right;"> Byte0~3               </th>
<th style="text-align:right;"> 4~9                  </th>
<th style="text-align:right;"> 10~15                 </th>
<th style="text-align:right;"> 16~31</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">0       </td>
<td style="text-align:right;">                       </td>
<td style="text-align:right;">                      </td>
<td style="text-align:right;"> 源端口号(Source Port) </td>
<td style="text-align:right;"> 目的端口号(Destination Port)</td>
</tr>
<tr>
<td style="text-align:left;">32      </td>
<td style="text-align:right;">                       </td>
<td style="text-align:right;">                      </td>
<td style="text-align:right;">                      </td>
<td style="text-align:right;"> 序号(Sequence Number)</td>
</tr>
<tr>
<td style="text-align:left;">64      </td>
<td style="text-align:right;">                       </td>
<td style="text-align:right;">                      </td>
<td style="text-align:right;">                      </td>
<td style="text-align:right;"> 确认号(Acknowledgemen Number)</td>
</tr>
<tr>
<td style="text-align:left;">96      </td>
<td style="text-align:right;"> 数据偏移(Date Offest)  </td>
<td style="text-align:right;"> 保留(Reserved)        </td>
<td style="text-align:right;"> 标示符                </td>
<td style="text-align:right;"> 窗口大小(Window)</td>
</tr>
<tr>
<td style="text-align:left;">128     </td>
<td style="text-align:right;">                       </td>
<td style="text-align:right;">                      </td>
<td style="text-align:right;"> 检验码(Checksum)      </td>
<td style="text-align:right;"> 紧急数据指针(Urgent Pointer)</td>
</tr>
<tr>
<td style="text-align:left;">160     </td>
<td style="text-align:right;">                                                                     </td>
<td style="text-align:right;"> 选项(options)</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;">192+    </td>
<td style="text-align:right;">                                                                     </td>
<td style="text-align:right;"> 数据(Data)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>


<p><br /></p>

<h5>源端口号</h5>

<p>本地通信端口</p>

<h5>目的端口号</h5>

<p>远地通信端口</p>

<h5>序号</h5>

<p>数据部分第一字节的序列号</p>

<h5>确认号</h5>

<p>表示本地希望接收得下一个数据字节的序号</p>

<h5>数据偏移</h5>

<p>该TCP段中数据起始的位置</p>

<h5>保留</h5>

<p>该域保留，置位为0</p>

<h5>标示符</h5>

<ul>
<li>URG:紧急数据指针有效标志，指示本段中包含紧急数据</li>
<li>ACK:确认标志，指示段中确认号有效</li>
<li>PST:复位连接标志，指示本段为复位段</li>
<li>RSH:PUSH操作标志</li>
<li>SYN:建立同步连接标志</li>
<li>FIN:本地数据发送结束，终止链接标志</li>
</ul>


<h5>窗口大小</h5>

<p>本地接受窗口（接受缓冲区）大小</p>

<h5>校验和</h5>

<p>包括TCP报头和数据在内的校验和</p>

<h5>紧急数据指针</h5>

<p>指示从发送数据序列号开始到紧急数据之后的第一个字节偏移</p>

<h5>选项</h5>

<p>提供任选服务</p>

<h5>数据</h5>

<p>保证TCP报头以32位为边界对齐</p>

<h2>IP</h2>

<p>网际协议（Internet Protocol），是用于报文交换网络的一种面向数据的协议。</p>

<p>IP是在TCP/IP协议中网络层的主要协议，任务是仅仅根据源主机和目的主机的地址传送数据。为此目的，IP定义了寻址方法和数据报的封装结构 。第一个架构的主要版本，现在称为IPv4，仍然是最主要的互联网协议，尽管世界各地正在积极部署IPv6。</p>

<h4>IP报文格式</h4>

<table>
<thead>
<tr>
<th style="text-align:left;">0            </th>
<th style="text-align:right;"> 3             </th>
<th style="text-align:right;"> 7                  </th>
<th style="text-align:right;"> 15        </th>
<th style="text-align:right;"> 18              </th>
<th style="text-align:right;"> 31</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">版本         </td>
<td style="text-align:right;"> 标头长度        </td>
<td style="text-align:right;"> 服务类型            </td>
<td style="text-align:right;">           </td>
<td style="text-align:right;">                 </td>
<td style="text-align:right;"> 封包总长</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:right;">               </td>
<td style="text-align:right;"> 识别码              </td>
<td style="text-align:right;"> 旗标       </td>
<td style="text-align:right;">                 </td>
<td style="text-align:right;"> 分割定位</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:right;"> 存活时间       </td>
<td style="text-align:right;"> 协定                </td>
<td style="text-align:right;">           </td>
<td style="text-align:right;">                 </td>
<td style="text-align:right;"> 标头检验值</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:right;">               </td>
<td style="text-align:right;">                    </td>
<td style="text-align:right;">           </td>
<td style="text-align:right;">                 </td>
<td style="text-align:right;"> 源地址</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:right;">               </td>
<td style="text-align:right;">                    </td>
<td style="text-align:right;">           </td>
<td style="text-align:right;">                 </td>
<td style="text-align:right;"> 目的地址</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:right;"> 可选           </td>
<td style="text-align:right;">                    </td>
<td style="text-align:right;">           </td>
<td style="text-align:right;">                 </td>
<td style="text-align:right;"> 填充</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:right;">               </td>
<td style="text-align:right;">                    </td>
<td style="text-align:right;">           </td>
<td style="text-align:right;">                 </td>
<td style="text-align:right;"> 数据</td>
</tr>
</tbody>
</table>


<p><br /></p>

<h5>版本（Version）</h5>

<p>IP规格版本，目前IP多为版本4，所以这里通常为0x4</p>

<h5>标头长度（Internet Header Length）</h5>

<p>在Option和Padding没有设定的情况下，标头只有5行的长度，每行4Byte，共20Byte；所以这里通常为0x14</p>

<h5>服务类型（Type of Service）</h5>

<p>IP封包在传送过程中的服务类型，由8个bit组成，每组bit组合代表不同的意思。</p>

<ul>
<li>000&hellip;..  Routine       设定IP顺序，预设为0，否则数值越高越优先</li>
<li>&hellip;0&hellip;.  Delay         延迟要求，0为正常值，1为低要求</li>
<li>&hellip;.0&hellip;  Throughput    通讯量要求，0为正常值，1为高要求</li>
<li>&hellip;..0..  Reliability   可靠性要求，0为正常值，1为高要求</li>
<li>&hellip;&hellip;00  Not Used      未使用</li>
</ul>


<h5>封包总长（Total Length）</h5>

<p>通常以Byte做单位来表示该封包的总长度，此数值包括标头和数据的总和</p>

<h5>识别码 （Identification）</h5>

<p>每一个IP封包都有一个16bit的唯一识识别码。当程式产生的数据要通过网络传送时，都会在传送层被拆散成封包形式发送，当封包要进行重组的时候，就是依据这个ID。</p>

<h5>旗标（Flag）</h5>

<p>这是当封包在传送过程中进行最佳组合时使用的3个bit的识别记号。</p>

<ul>
<li><ol>
<li>  当此值为0的时候，表示目前未被使用。</li>
</ol>
</li>
<li>.0..  当此值为0的时候，表示封包可以被分割，若为1则不能被分割</li>
<li>..0.  当上一个值为0时，此值为0就表示该封包是最后一个封包，如果为1则表示其后还有被分割的封包</li>
</ul>


<h5>分割定位（Fragment Offset）</h5>

<p>当一个大封包在经过一些传输单位（MTU）较小的路径时，会被切割成碎片（fragment）再进行传送（这个切割和传送层的打包有所不同，它是由网络层决定的）。由于网络情况或其他因素影响，其抵达顺序并不会和当初切割顺序一致的。所以当封包进行切割的时候，会为各片段做好定位记录，如果封包没有被切割，那么值为0</p>

<h5>存活时间（Time To Live）</h5>

<p>当一个封包被赋予TTL值，TTL是以hop为单位，没经过一个router就减一，如果封包TTL值被降为0的时候，就会被丢弃。这样，当封包在传送过程中由于某些原因而未能抵达目的地的时候，就可以避免其一直充斥在网络上面。</p>

<h5>协定（Protocol）</h5>

<p>这里指的是该封包所使用的网络协议类型。各协议的代号如下：</p>

<ul>
<li>ip      0       IP              # internet protocol, pseudo protocol number</li>
<li>icmp    1       ICMP            # internet control message protocol</li>
<li>igmp    2       IGMP            # Internet Group Management</li>
<li>ggp     3       GGP             # gateway-gateway protocol</li>
<li>ipencap 4       IP-ENCAP        # IP encapsulated in IP (officially &ldquo;IP&rdquo;)</li>
<li>st      5       ST              # ST datagram mode</li>
<li>tcp     6       TCP             # transmission control protocol</li>
<li>egp     8       EGP             # exterior gateway protocol</li>
<li>pup     12      PUP             # PARC universal packet protocol</li>
<li>udp     17      UDP             # user datagram protocol</li>
<li>hmp     20      HMP             # host monitoring protocol</li>
<li>xns-idp 22      XNS-IDP         # Xerox NS IDP</li>
<li>rdp     27      RDP             # &ldquo;reliable datagram&rdquo; protocol</li>
<li>iso-tp4 29      ISO-TP4         # ISO Transport Protocol class 4</li>
<li>xtp     36      XTP             # Xpress Tranfer Protocol</li>
<li>ddp     37      DDP             # Datagram Delivery Protocol</li>
<li>idpr-cmtp       39      IDPR-CMTP       # IDPR Control Message Transport</li>
<li>rspf    73      RSPF            #Radio Shortest Path First.</li>
<li>vmtp    81      VMTP            # Versatile Message Transport</li>
<li>ospf    89      OSPFIGP         # Open Shortest Path First IGP</li>
<li>ipip    94      IPIP            # Yet Another IP encapsulation</li>
<li>encap   98      ENCAP           # Yet Another IP encapsulation</li>
</ul>


<h5>标头检验值（Header Checksum）</h5>

<p>这个数值主要是用来检错用的，用以确保封包被正确无误的接收到。如果一切无误，就会发出确认信息，表示接收正常。</p>

<h5>源地址（Source IP Address）</h5>

<p>发送端IP地址。</p>

<h5>目的地址（Destination IP Address）</h5>

<p>接收端IP地址。</p>

<h5>可选&amp;填充（Options&amp;Padding）</h5>

<p>Options长度不定，可用来扩充功能。
Padding是为了让表头刚好是4Byte的倍数。</p>

<h5>数据（Data）</h5>

<h2>ICMP</h2>

<p>ICMP（Internet Control Message Protocol）是Internet控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p>

<h4>ICMP报文格式</h4>

<p>ICMP报头从IP报头的第160位开始（例外：除非使用了IP报头的可选部分）</p>

<p>0            | 7                   | 15                              | 31
:&mdash;&mdash;&mdash;-  | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;: | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;: | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-:
类型          | 代码                |                                 | 检验和
             | 标识符               |                                 | 序列号<br/>
             |                     |                                 | 选项
<br /></p>

<h5>类型（type）</h5>

<p>ICMP的类型</p>

<h5>代码（code）</h5>

<p>进一步分割ICMP的类型；</p>

<table>
<thead>
<tr>
<th style="text-align:center;">type </th>
<th style="text-align:center;"> code </th>
<th style="text-align:left;"> description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">0    </td>
<td style="text-align:center;"> 0    </td>
<td style="text-align:left;"> Echo Reply —— 回显应答（Ping 应答）</td>
</tr>
<tr>
<td style="text-align:center;">3    </td>
<td style="text-align:center;"> 0    </td>
<td style="text-align:left;"> Network Unreachable —— 网络不可达</td>
</tr>
<tr>
<td style="text-align:center;">3    </td>
<td style="text-align:center;"> 1    </td>
<td style="text-align:left;"> Host Unreachable —— 主机不可达</td>
</tr>
<tr>
<td style="text-align:center;">3    </td>
<td style="text-align:center;"> 2    </td>
<td style="text-align:left;"> Protocol Unreachable —— 协议不可达</td>
</tr>
<tr>
<td style="text-align:center;">3    </td>
<td style="text-align:center;"> 3    </td>
<td style="text-align:left;"> Port Unreachable —— 端口不可达</td>
</tr>
<tr>
<td style="text-align:center;">3    </td>
<td style="text-align:center;"> 4    </td>
<td style="text-align:left;"> Fragmentation needed but no frag bit set —— 需要进行分片但设置不分片比特</td>
</tr>
<tr>
<td style="text-align:center;">3    </td>
<td style="text-align:center;"> 5    </td>
<td style="text-align:left;"> Source routing failed —— 源站选路失败</td>
</tr>
<tr>
<td style="text-align:center;">3    </td>
<td style="text-align:center;"> 6    </td>
<td style="text-align:left;"> Destination network unknown —— 目的网络未知</td>
</tr>
<tr>
<td style="text-align:center;">3    </td>
<td style="text-align:center;"> 7    </td>
<td style="text-align:left;"> Destination host unknown —— 目的主机未知</td>
</tr>
<tr>
<td style="text-align:center;">3    </td>
<td style="text-align:center;"> 8    </td>
<td style="text-align:left;"> Source host isolated（obsolete）—— 源主机被隔离（作废不用）</td>
</tr>
<tr>
<td style="text-align:center;">3    </td>
<td style="text-align:center;"> 9    </td>
<td style="text-align:left;"> Destination network administratively prohibited —— 目的网络被强制禁止</td>
</tr>
<tr>
<td style="text-align:center;">3    </td>
<td style="text-align:center;"> 10   </td>
<td style="text-align:left;"> Destination host administratively prohibited —— 目的主机被强制禁止</td>
</tr>
<tr>
<td style="text-align:center;">3    </td>
<td style="text-align:center;"> 11   </td>
<td style="text-align:left;"> Network unreachable for TOS——由于服务类型TOS，网络不可达</td>
</tr>
<tr>
<td style="text-align:center;">3    </td>
<td style="text-align:center;"> 12   </td>
<td style="text-align:left;"> Host unreachable for TOS——由于服务类型TOS，主机不可达</td>
</tr>
<tr>
<td style="text-align:center;">3    </td>
<td style="text-align:center;"> 13   </td>
<td style="text-align:left;"> Communication administratively prohibited by filtering——由于过滤，通信被强制禁止</td>
</tr>
<tr>
<td style="text-align:center;">3    </td>
<td style="text-align:center;"> 14   </td>
<td style="text-align:left;"> Host precedence violation——主机越权</td>
</tr>
<tr>
<td style="text-align:center;">3    </td>
<td style="text-align:center;"> 15   </td>
<td style="text-align:left;"> Precedence cutoff in effect——优先中止生效</td>
</tr>
<tr>
<td style="text-align:center;">4    </td>
<td style="text-align:center;"> 0    </td>
<td style="text-align:left;"> Source quench——源端被关闭（基本流控制）</td>
</tr>
<tr>
<td style="text-align:center;">5    </td>
<td style="text-align:center;"> 0    </td>
<td style="text-align:left;"> Redirect for network——对网络重定向</td>
</tr>
<tr>
<td style="text-align:center;">5    </td>
<td style="text-align:center;"> 1    </td>
<td style="text-align:left;"> Redirect for host——对主机重定向</td>
</tr>
<tr>
<td style="text-align:center;">5    </td>
<td style="text-align:center;"> 2    </td>
<td style="text-align:left;"> Redirect for TOS and network——对服务类型和网络重定向</td>
</tr>
<tr>
<td style="text-align:center;">5    </td>
<td style="text-align:center;"> 3    </td>
<td style="text-align:left;"> Redirect for TOS and host——对服务类型和主机重定向</td>
</tr>
<tr>
<td style="text-align:center;">8    </td>
<td style="text-align:center;"> 0    </td>
<td style="text-align:left;"> Echo request——回显请求（Ping请求）</td>
</tr>
<tr>
<td style="text-align:center;">9    </td>
<td style="text-align:center;"> 0    </td>
<td style="text-align:left;"> Router advertisement——路由器通告</td>
</tr>
<tr>
<td style="text-align:center;">10   </td>
<td style="text-align:center;"> 0    </td>
<td style="text-align:left;"> Route solicitation——路由器请求</td>
</tr>
<tr>
<td style="text-align:center;">11   </td>
<td style="text-align:center;"> 0    </td>
<td style="text-align:left;"> TTL equals 0 during transit——传输期间生存时间为0</td>
</tr>
<tr>
<td style="text-align:center;">11   </td>
<td style="text-align:center;"> 1    </td>
<td style="text-align:left;"> TTL equals 0 during reassembly——在数据报组装期间生存时间为0</td>
</tr>
<tr>
<td style="text-align:center;">12   </td>
<td style="text-align:center;"> 0    </td>
<td style="text-align:left;"> IP header bad (catchall error)——坏的IP首部（包括各种差错）</td>
</tr>
<tr>
<td style="text-align:center;">12   </td>
<td style="text-align:center;"> 1    </td>
<td style="text-align:left;"> Required options missing——缺少必需的选项</td>
</tr>
<tr>
<td style="text-align:center;">13   </td>
<td style="text-align:center;"> 0    </td>
<td style="text-align:left;"> Timestamp request (obsolete)——时间戳请求（作废不用）</td>
</tr>
<tr>
<td style="text-align:center;">14   </td>
<td style="text-align:center;">      </td>
<td style="text-align:left;"> Timestamp reply (obsolete)——时间戳应答（作废不用）</td>
</tr>
<tr>
<td style="text-align:center;">15   </td>
<td style="text-align:center;"> 0    </td>
<td style="text-align:left;"> Information request (obsolete)——信息请求（作废不用）</td>
</tr>
<tr>
<td style="text-align:center;">16   </td>
<td style="text-align:center;"> 0    </td>
<td style="text-align:left;"> Information reply (obsolete)——信息应答（作废不用）</td>
</tr>
<tr>
<td style="text-align:center;">17   </td>
<td style="text-align:center;"> 0    </td>
<td style="text-align:left;"> Address mask request——地址掩码请求</td>
</tr>
<tr>
<td style="text-align:center;">18   </td>
<td style="text-align:center;"> 0    </td>
<td style="text-align:left;"> Address mask reply——地址掩码应答</td>
</tr>
</tbody>
</table>


<p><br /></p>

<h5>检验和（checksum）</h5>

<p>这个字段包含有从ICMP报头和数据部分计算得来的，用于检查错误的数据，其中此校验码字段的值视为0。</p>

<h5>标识符（Identifier）</h5>

<p>这个字段包含ID值，在Echo Reply 类型的消息中要返回这个字段。</p>

<h5>序列号（sequence）</h5>

<p>这个字段包含一个序号，同样要在echo reply类型的消息中要返回这个字段。</p>

<h5>选项</h5>

<p>可无。</p>

<h4>参考资料</h4>

<ul>
<li><a href="http://www.study-area.org/network/networkfr.htm">http://www.study-area.org/network/networkfr.htm</a></li>
<li><a href="http://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F">http://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Pod]]></title>
    <link href="http://viczy.github.io/blog/2015/03/08/ios-pod/"/>
    <updated>2015-03-08T10:42:50+08:00</updated>
    <id>http://viczy.github.io/blog/2015/03/08/ios-pod</id>
    <content type="html"><![CDATA[<h2>pod文件样本</h2>

<pre><code>source 'https://github.com/CocoaPods/Specs.git'

# platform :ios
platform :ios, '6.0'

# ignore all warnings from all pods
inhibit_all_warnings!

#Network
pod 'AFNetworking'
pod 'SDWebImage'    #功能类似UIImageView+AFNetworking
pod 'UIActivityIndicator-for-SDWebImage' #SDWebImage的拓展模块

#View
pod 'TPKeyboardAvoiding'    #根据键盘滑动的各类ScrollView
pod 'EAIntroView'   #引导页面
pod 'AwesomeMenu', '~&gt; 1.0.0'   #path菜单
pod 'RESideMenu', '~&gt; 4.0.7'    #侧边菜单
pod 'REMenu', '~&gt; 1.10'     #下拉菜单
pod 'MRProgress', '~&gt; 0.8.1'    #hud(ios7)
pod 'MBProgressHUD', '~&gt; 0.8'   #hud
pod 'SVProgressHUD'     #hud
pod 'MMProgressHUD', :git =&gt; 'https://github.com/lanvige/MMProgressHUD' #hud
pod 'MMSuperViewController', :git =&gt; 'https://github.com/lanvige/MMSuperViewController.git'     #下拉刷新
pod 'VTextView', :git =&gt; 'https://github.com/viczy/VTextView.git'   #类似微博文版
pod 'VPageScrollView', :git =&gt; 'https://github.com/viczy/VPageScrollView.git'   #滚动页（可循环）
pod 'VPopImageView', :git =&gt; 'https://github.com/viczy/VPopImageView.git'   #可弹出的imageview

#Data
pod 'NSString+Pinyin'   #中文字母化
pod 'RegexKitLite'  #正则
pod 'SSZipArchive'  #压缩
pod 'FMDB'  #数据库
pod 'Mantle'    #数据处理
pod 'JSONKit-NoWarning' #josn

#Tool
pod 'CocoaLumberjack'   #log
pod 'ReactiveCocoa'     #函数式编程
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网络初窥]]></title>
    <link href="http://viczy.github.io/blog/2014/12/06/wang-luo-chu/"/>
    <updated>2014-12-06T17:36:08+08:00</updated>
    <id>http://viczy.github.io/blog/2014/12/06/wang-luo-chu</id>
    <content type="html"><![CDATA[<h3>DNS</h3>

<p>DNS服务器是计算机域名系统 (Domain Name System 或Domain Name Service) 的缩写，它是由域名解析器和域名服务器组成的。域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并具有将域名转换为IP地址功能的服务器。其中域名必须对应一个IP地址，而IP地址不一定有域名。</p>

<h4>域名由来</h4>

<p>IP地址是Internet主机的作为路由寻址用的数字型标识，人不容易记忆。因而产生了域名（domain name）这一种字符型标识。</p>

<p>一个域名的“所有者”可以通过查询<code>whois</code>数据库而被找到；对于大多数<code>gTLD</code>（Generic top-level domain），基本的WHOIS由<code>ICANN</code>（The Internet Corporation for Assigned Names and Numbers）维护，而WHOIS的细节则由控制那个域的域注册机构维护。至於有240個以上的國家域名（<code>ccTLDs</code>）的域註冊由相應的國家維護其WHOIS。</p>

<h4>域名注册</h4>

<p>一般來說，gTLD域名的管理機構，都僅制定域名政策，而不涉入用戶註冊事宜，這些機構會將註冊事宜授權給通過審核的頂級註冊商，再由頂級註冊商向下授權給其它二、三級代理商。</p>

<p>ccTLD的註冊就比較複雜，除了遵循前述規範外，部份國家如前述將域名轉包給某些公司管理（如西薩摩亞ws），亦有管理機構兼頂級註冊機構的狀況：（如南非za）。</p>

<p>各種域名註冊所需資格不同，gTLD除少數例外（如travel）外，一般均不限資格；而ccTLD則往往有資格限制，甚至必需繳驗實體證件。</p>

<p>一个域名的所有者可以通过查询WHOIS数据库而被找到；对于大多数根域名服务器，基本的WHOIS由ICANN维护，而WHOIS的细节则由控制那个域的域注册机构维护。</p>

<h3>IP,子网掩码，网关，DHCP，ARP（来自知乎回答的比较通俗的解释）</h3>

<p>计算机主机网关的作用是什么？</p>

<p>假设你的名字叫小不点，你住在一个大院子里，你的邻居有很多小伙伴，在门口传达室还有个看大门的李大爷，李大爷就是你的网关。当你想跟院子里的某个小伙伴玩，只要你在院子里大喊一声他的名字，他听到了就会回应你，并且跑出来跟你玩。</p>

<p>但是你不被允许走出大门，你想与外界发生的一切联系，都必须由门口的李大爷（网关）用电话帮助你联系。假如你想找你的同学小明聊天，小明家住在很远的另外一个院子里，他家的院子里也有一个看门的王大爷（小明的网关）。但是你不知道小明家的电话号码，不过你的班主任老师有一份你们班全体同学的名单和电话号码对照表，你的老师就是你的DNS服务器。于是你在家里拨通了门口李大爷的电话，有了下面的对话：</p>

<p>小不点：李大爷，我想找班主任查一下小明的电话号码行吗？</p>

<p>李大爷：好，你等着。（接着李大爷给你的班主任挂了一个电话，问清楚
了小明的电话）问到了，他家的号码是211.99.99.99</p>

<p>小不点：太好了！李大爷，我想找小明，你再帮我联系一下小明吧。</p>

<p>李大爷：没问题。（接着李大爷向电话局发出了请求接通小明家电话的请
求，最后一关当然是被转接到了小明家那个院子的王大爷那里，然后王大
爷把电话给转到小明家）</p>

<p>就这样你和小明取得了联系。</p>

<p>至于DHCP服务器嘛，可以这样比喻：</p>

<p>你家院子里的居民越来越多了，传达室李大爷那里的电话交换机已经不能满足这么多居民的需求了，所以只好采用了一种新技术叫做DHCP，居民们开机的时候随机得到一个电话号码，每一次得到的号码都可能会不同。</p>

<p>你家门口的李大爷：就是你的网关</p>

<p>你的班主任：就是你的DNS服务器</p>

<p>传达室的电话交换机：就是你的DHCP服务器</p>

<p>同上，李大爷和王大爷之间的对话就叫做路由。</p>

<p>另：如果还有个小朋友叫做小暗，他住的院子看门的是孙大爷，因为小暗的院子刚盖好，孙大爷刚来不久，他没有李大爷和王大爷办公室的电话（李大爷和王大爷当然也没有他的电话），这时会有两种情况：</p>

<p>1、居委会的赵大妈告诉了孙大爷关于李、王两位大爷的电话（同时赵大妈也告诉了李、王关于孙的电话），这就叫静态设定路由</p>

<p>2、赵大妈病了，孙大爷自己到处打电话，见人就说：“我是小暗他们院子管电话的”，结果被李、王二位听到了，就记在了他们的通讯录上，然后李、王就给孙大爷回了个电话说：“我是小明（小不点）他们院子管电话的”，这就叫动态设定路由</p>

<p>然后有一天小不点要找小暗，结果自然是小不点给李大爷打电话说：“大爷，我找小暗”（这里省略了李大爷去查小暗电话的过程，假设他知道小暗的电话），李大爷一找通讯录：“哦，小暗的院子的电话是孙大爷管着的，要找小暗自然先要通知孙大爷，我可以通知王大爷让他去找孙大爷，也可以自己直接找孙，那当然是自己直接找孙方便了”，于是李大爷给孙大爷打了电话，然后孙大爷又把电话转到了小暗家。</p>

<p>这里李大爷的通讯录叫做路由表。</p>

<p>李大爷选择是自己直接找孙大爷还是让王大爷帮忙转接叫做路由选择。</p>

<p>李大爷之所以选择直接找孙大爷是有依据的，因为他直接找孙大爷就能一步到位，如果要王大爷转接就需要两步才能完成，这里的“步”叫做“跳数”，李大爷的选择遵循的是最少步骤（跳数）原则（如果他不遵守这个原则，小不点可能就会多等些时间才能找到小暗，最终结果可能导致李大爷因工作不力被炒鱿鱼，这叫做“延时太长，选路原则不合理，换了一个路由器”）</p>

<p>当然，事情总是变化的，小不点和小明吵架了，这些天小不点老是给小暗打电话，小明心里想：“操，他是不是在说我坏话啊？”于是小明决定偷听小不点和小暗的通话，但是他又不能出院子，怎么办呢？小明做了这样一个决定：</p>

<p>首先他告诉自己院里管电话的王大爷说：“你给李大爷打个电话说小暗搬到咱们院子了，以后凡是打给他的电话我来接”，王大爷没反映过来（毕竟年纪大了啊！）就给李大爷打了电话，说：“现在我来管理小暗的电话了，孙已经不管了”，结果李大爷就把他的通讯录改了，这叫做路由欺骗。
以后小不点再找小暗，李大爷就转给王大爷了（其实应该转给孙大爷的），王大爷收到了这个电话就转给了小明（因为他之前已经和小明说好了），小明收到这个电话就假装小暗和小不点通信。因为小明作贼心虚，害怕明天小不点和小暗见面后当面问他，于是通信断了之后，又自己以小不点的名义给小暗通了个电话复述了一遍刚才的话，有这就叫数据窃听</p>

<p>再后来，小不点还是不断的和小暗联系，而零落了小明，小明心里嘀咕啊：“我不能总是这样以小暗的身份和小不点通话啊，外一有一天露馅了怎么办！”于是他想了一个更阴险的招数：“干脆我也不偷听你们的电话了，你小不点不是不给我打电话吗！那我让你也给小暗打不了，哼哼！”，他怎么做的呢？我们来看：</p>

<p>他联系了一批狐朋狗友，和他们串通好，每天固定一个时间大家一起给小暗院子传达室打电话，内容什么都有，只要传达室的孙爷爷接电话，就会听到“打雷啦，下雨收衣服啊！”、“人是人他妈生的，妖是妖他妈生的”、“你妈贵姓”等等，听的脑袋都大了，不听又不行，电话不停的响啊！终于有一天，孙爷爷忍不住了，大喊一声：“我受不了拉！！！！”，于是上吊自杀了！
这就是最简单的DDOS攻击，孙爷爷心理承受能力弱的现象叫做“数据报处理模块有BUG”，孙爷爷的自杀叫做“路由器瘫痪”。如果是我，就会微笑着和他们拉家常，例如告诉他们“我早就听了天气预报，衣服10分钟前已经收好了”或者“那你妈是人还是妖”或者“和你奶奶一个姓”等等，我这种健全的心理叫做“健壮的数据报处理，能够抵御任何攻击”</p>

<p>孙爷爷瘫了之后，小不点终于不再给小暗打电话了，因为无论他怎么打对方都是忙音，这种现象叫做“拒绝服务”，所以小明的做法还有一个名字叫做“拒绝服务攻击”。
小明终于安静了几天，&hellip;</p>

<p>几天后，小明的院子来了一个美丽的女孩，名字叫做小丽，小明很喜欢她（小小年纪玩什么早恋！）可是小丽有个很帅的男朋友，小明干瞪眼没办法。当然这里还是要遵循上面的原则：小丽是不能出院子的。那个男的想泡小丽自然只能打电话，于是小明又蠢蠢欲动了：
还记得王爷爷是院子的电话总管吗？他之所以能管理电话是因为他有一个通讯录，因为同一个院子可能有2个孩子都叫小明，靠名字无法区分，所以通讯录上每一行只有两项：
门牌电话</p>

<p>一号门 1234567 （这个是小明的）</p>

<p>二号门 7654321 （这个是小丽的）</p>

<p>&hellip;&hellip;</p>

<p>王爷爷记性不好，但这总不会错了吧（同一个院子不会有2个“二号门”吧）？每次打电话人家都要说出要找的电话号码，然后通过通讯录去院子里面敲门，比如人家说我找“1234567”，于是王爷爷一比较，哦，是一号门的，他就去敲一号门“听电话”，如果是找“7654321”，那他就找二号门“听电话”。</p>

<p>这里的电话号码就是传说中的“IP地址”</p>

<p>这里的门牌号就是传说中的网卡的’MAC‘地址（每一块网卡的MAC地址都是不一样的，这是网卡的制造商写死在网卡的芯片中的）</p>

<p>小明心里想“奶奶的，老子泡不到你也别想泡”，于是他打起了王爷爷通讯录的主意，经过细心的观察，周密的准备，他终于发现王爷爷有尿频的毛病（毕竟是老人啊&hellip;），终于在一个月黑风高的白天，王爷爷去上厕所了，小明偷偷的摸进传达室，小心翼翼的改了王爷爷的通讯录&hellip;&hellip;</p>

<p>过了几天，小丽的男朋友又给小丽打来了电话，对方报的电话是“7654321”，王爷爷一看通讯录，靠：</p>

<p>门牌电话</p>

<p>一号门 1234567 （这个是小明的）</p>

<p>一号门 7654321 （注意：这个原来是小丽的，但是被小明改了）</p>

<p>&hellip;&hellip;</p>

<p>王爷爷不知道改了啊，于是就去找一号门的小明了，小明心里这个美啊，他以小丽父亲的口吻严厉的教训了那个男的和小丽之间不正当的男女关系，结果那个男的恭恭敬敬的挂了电话。当然小丽并不知道整个事情的发生&hellip;</p>

<p>这里小明的行为叫做“ARP欺骗”（因为在实际的网络上是通过发送ARP数据包来实现的，所以叫做“ARP欺骗”），王爷爷的通讯录叫做“ARP表”</p>

<p>这里要注意：王爷爷现在有两个通讯录了，一个是记录每个院子传达室电话的本本，叫做“路由表”，一个是现在说的记录院子里面详细信息的本本，叫做“ARP表”。</p>

<p>有句命言是“人们总是在追求完美的，尽管永远也做不到”（请记住这句话，因为这是一个大名人&ndash;也就是我，说的）</p>

<p>王爷爷的制度中有一条是这么写的“每个月要重新检查一下门牌号和电话的对应本（也就是ARP表）”，这个动作叫做“刷新ARP表”，每个月的时间限制叫做“刷新ARP表的周期”。这样小明为了让那个男的永远不能找到小丽，之后每个月都要偷偷改一次那个通讯录，不过这样也是不得不做的事啊！</p>

<p>补充一点，小明是很聪明的，如果通讯录（ARP表）被改成了这样：</p>

<p>门牌（MAC）电话（IP）</p>

<p>一号门 1234567 （这个是小明的）</p>

<p>二号门 1234567 （注意：这个被小明改了，但是他一时头晕改错了）</p>

<p>&hellip;&hellip;</p>

<p>就会是计算机就会弹出一个对话框提示“出现重复的IP地址”，最终会导致王爷爷不知所措，于是通知一号门和二号门，你们的电话重复了。这样小丽就知道有人在破坏她的好事，这个现象叫做“骗局被揭穿了”</p>

<p>小不点知道了小明偷听他和小暗的电话，于是就和小暗约定好了密码。小不点在家里把要说的加密了之后告诉小暗。土豆－〉星期三，地瓜－〉请客，笨蛋－〉小不点家。于是小不点告诉小暗：土豆笨蛋地瓜。小明听了？？？不懂。。。。郁闷了。。。这是加密。</p>

<p>除此之外，小丽也知道了小明改他家的电话号码了。于是王爷爷就登门一个一个把电话和门牌号记下来。并且藏起来不允许外人修改，只能自己有钥匙（密码）。这是ip地址和MAC地址绑定。当有人改了电话号码的时候，就得找王爷爷改。麻烦是麻烦了，但是安全了。不过小明偷偷的把王爷爷的钥匙偷配了一把（盗窃密码成功），于是他还可以修改。这样么，就这样了。</p>

<h4>子网掩码</h4>

<p>子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。</p>

<p>例如：</p>

<p>IP地址　 192.168.1.23</p>

<p>子网掩码　255.255.255.0</p>

<p>网络地址为：192.168.1.0，主机地址：192.168.1.<code>23</code></p>

<h4>网关</h4>

<p>那么网关到底是什么呢？网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1~192.168.2.254”，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络A向网络B转发数据包的过程。</p>

<p>所以说，只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。那么这个IP地址是哪台机器的IP地址呢？网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。</p>

<h4>DHCP</h4>

<p>动态主机設定協定（Dynamic Host Configuration Protocol, DHCP）是一個局域网的网络协议，使用UDP协议工作，主要有兩個用途：</p>

<ul>
<li>給內部網路或網絡服務供應商自動分配IP地址給用戶</li>
<li>給內部網路管理員作為對所有電腦作中央管理的手段</li>
</ul>


<p>DHCP用一台或一组DHCP服务器来管理网络参数的分配，这种方案具有容错性。即使在一个仅拥有少量机器的网络中，DHCP仍然是有用的，因为一台机器可以几乎不造成任何影响地被增加到本地网络中。</p>

<p>甚至对于那些很少改变地址的服务器来说，DHCP仍然被建议用来设置它们的地址。如果服务器需要被重新分配地址（RFC2071）的时候，就可以在尽可能少的地方去做这些改动。对于一些设备，如路由器和防火墙，则不应使用DHCP。把TFTP或SSH服务器放在同一台运行DHCP的机器上也是有用的，目的是为了集中管理。</p>

<p>DHCP也可用于直接为服务器和桌面计算机分配地址，并且通过一个PPP代理，也可为拨号及宽带主机，以及住宅NAT网关和路由器分配地址。DHCP一般不适用于使用在无边际路由器和DNS服务器上。</p>

<h4>ARP</h4>

<p>地址解析协议（Address Resolution Protocol），其基本功能为通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。它是IPv4中网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。</p>

<p>以主机A（192.168.38.10）向主机B（192.168.38.11）发送数据为例。当发送数据时，主机A会在自己的ARP缓存表中寻找是否有目标IP地址。如果找到了，也就知道了目标MAC地址為（00-BB-00-62-C2-02），直接把目标MAC地址写入帧里面发送就可以了；如果在ARP缓存表中没有找到相对应的IP地址，主机A就会在网络上发送一个广播（ARP request），目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向同一网段内的所有主机发出这样的询 问：“192.168.38.11的MAC地址是什么？”网络上其他主机并不响应ARP询问，只有主机B接收到这个帧时，才向主机A做出这样的回应（ARP response）：“192.168.38.11的MAC地址是（00-BB-00-62-C2-02）”。 这样，主机A就知道了主机B的MAC地址，它就可以向主机B发送信息了。同时它还更新了自己的ARP缓存表，下次再向主机B发送信息时，直接从ARP缓存表里查找就可以了。ARP缓存表采用了老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可以大大减少ARP缓存表的长度，加快查询速度。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails环境配置]]></title>
    <link href="http://viczy.github.io/blog/2014/12/06/railshuan-jing-pei-zhi/"/>
    <updated>2014-12-06T17:33:48+08:00</updated>
    <id>http://viczy.github.io/blog/2014/12/06/railshuan-jing-pei-zhi</id>
    <content type="html"><![CDATA[<!-- # Rails

![Rails icon](http://upload.wikimedia.org/wikipedia/commons/9/9c/Ruby_on_Rails_logo.jpg) -->


<h2>Rails安装</h2>

<h3>Gem</h3>

<p>RubyGems（简称 gems）是一个用于对 Ruby组件进行打包的 Ruby 打包系统。 它提供一个分发 Ruby 程序和库的标准格式，还提供一个管理程序包安装的工具(<code>gem</code>)。Rails也是一个Ruby写的RubyGem。</p>

<p>Ruby从1.9版本开始内建RubyGems。或者选择下载安装（<a href="http://rubygems.org/">下载地址</a>）。</p>

<p>查看版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem -v</span></code></pre></td></tr></table></div></figure>


<p>更新版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem update --system</span></code></pre></td></tr></table></div></figure>


<p>查看已安装的gems</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem list</span></code></pre></td></tr></table></div></figure>


<p>查看remote端的gems</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem list -r</span></code></pre></td></tr></table></div></figure>


<p>安装gems</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem install cocoapods</span></code></pre></td></tr></table></div></figure>


<p>安装特定版本的gems</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem install -v 0.33.1 cocoapods</span></code></pre></td></tr></table></div></figure>


<p>升级gems</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem update cocoapods</span></code></pre></td></tr></table></div></figure>


<p>升级所有已安装gems</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem update</span></code></pre></td></tr></table></div></figure>


<p>卸载gems</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem uninstall cocoapods</span></code></pre></td></tr></table></div></figure>


<p>gems环境信息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem environment</span></code></pre></td></tr></table></div></figure>


<p>查看gems源</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem sources -l</span></code></pre></td></tr></table></div></figure>


<p>添加gems源</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem sources -a https://ruby.taobao.org/</span></code></pre></td></tr></table></div></figure>


<p>移除gems源</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem sources --remove https://ruby.taobao.org/</span></code></pre></td></tr></table></div></figure>


<h4>RVM管理多个gemset</h4>

<p>rvm可以在某版本ruby下建立多个gemset独立空间来用来安装不同套件组合</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rvm gemset create set1</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rvm gemset create set2</span></code></pre></td></tr></table></div></figure>


<p>查看已建立gemset列表</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rvm gemset list</span></code></pre></td></tr></table></div></figure>


<p>设置某个gemset为当前gems空间</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rvm gemset user set1</span></code></pre></td></tr></table></div></figure>


<p>清空某个gemset</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rvm gemset empty set1</span></code></pre></td></tr></table></div></figure>


<p>删除某个gemset</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rvm gemset delete set1</span></code></pre></td></tr></table></div></figure>


<h3>gem安装rails</h3>

<p>安装rails</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem install rails</span></code></pre></td></tr></table></div></figure>


<p>不需要文档的安装方式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem install rails --no-ri --no-rdoc</span></code></pre></td></tr></table></div></figure>


<p>rails版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rails -v</span></code></pre></td></tr></table></div></figure>


<h2>rails使用</h2>

<p><a href="http://guides.ruby-china.org/command_line.html">rails命令行</a></p>

<h4>官方网站</h4>

<p><a href="http://rubyonrails.org/">http://rubyonrails.org/</a></p>

<h4>Github</h4>

<p><a href="https://github.com/rails/rails">https://github.com/rails/rails</a></p>

<h4>参考资料</h4>

<ul>
<li><a href="http://guides.ruby-china.org/command_line.html">http://guides.ruby-china.org/command_line.html</a></li>
<li><a href="https://ruby-china.org/wiki/install_ruby_guide">https://ruby-china.org/wiki/install_ruby_guide</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Certificates, Identifiers &amp; Profiles]]></title>
    <link href="http://viczy.github.io/blog/2014/11/30/certificates-identifiers-and-profiles/"/>
    <updated>2014-11-30T23:19:11+08:00</updated>
    <id>http://viczy.github.io/blog/2014/11/30/certificates-identifiers-and-profiles</id>
    <content type="html"><![CDATA[<p>苹果开发证书的生成是通过上传xxx.csr（rsa加密的签名）给CA生成xxx.cer证书文件。cer证书包括发布的证书，notification_push等功能拓展证书。
当生成Indentifiers时如果选择拓展的功能的时候，需要有对应的功能拓展证书。
生成Profiles时，需要选着对应的Indentifier与cer文件。</p>

<h2>certificate</h2>

<p>对于开发者而言，证书有效，Indentifiers和Profiles对应的生成便可。而有效的证书要保证证书在有效期外还要有证书的权限（private key）。</p>

<h3>CSR</h3>

<p>要了解证书签名请求（csr），首先了解RSA</p>

<h4>RSA</h4>

<p>RSA（非对称加密算法）简单的理解就是有一个公钥，一个私钥；公钥加密数据为<code>锁</code>，私钥用来解密数据位<code>钥匙</code>。</p>

<p><em>维基百科上有对rsa签名消息的解释：</em></p>

<pre><code>RSA也可以用来为一个消息署名。假如甲想给乙传递一个署名的消息的话，那么她可以为她的消息计算一个散列值(Message digest)，然后用她的密钥(private key)加密这个散列值并将这个“署名”加在消息的后面。这个消息只有用她的公钥才能被解密。乙获得这个消息后可以用甲的公钥解密这个散列值，然后将这个数据与他自己为这个消息计算的散列值相比较。假如两者相符的话，那么他就可以知道发信人持有甲的密钥，以及这个消息在传播路径上没有被篡改过。
</code></pre>

<p>如果证书实在生成签名的机器上使用没有问题，但到其他机器上便会遇到找不到私钥，无法使用的情况。</p>

<h3>p12</h3>

<p>对于解决公用证书其他机器没有私钥的解决方法是，在可以使用的机器上导出该证书为.p12格式，并设置密码。在该格式文件中将包含我们证书所需要的私钥。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS屏幕适配]]></title>
    <link href="http://viczy.github.io/blog/2014/11/30/iosping-mu-gua-pei/"/>
    <updated>2014-11-30T22:50:08+08:00</updated>
    <id>http://viczy.github.io/blog/2014/11/30/iosping-mu-gua-pei</id>
    <content type="html"><![CDATA[<h2>比对表</h2>

<table>
<thead>
<tr>
<th> 型号/参数   </th>
<th> Iphone3GS-  </th>
<th> Iphone4+   </th>
<th>  Iphone5+  </th>
<th>  Iphone6  </th>
<th> Iphone6Plus       </th>
</tr>
</thead>
<tbody>
<tr>
<td> PT         </td>
<td>   320X480   </td>
<td> 320X480    </td>
<td>  320X568   </td>
<td>  375X667  </td>
<td>  414X736          </td>
</tr>
<tr>
<td> 渲染PX      </td>
<td>   320X480   </td>
<td> 640X960    </td>
<td>  640X1136  </td>
<td>  750X1334 </td>
<td> 1242X2208         </td>
</tr>
<tr>
<td> 物理PX      </td>
<td>   320X480   </td>
<td> 640X960   </td>
<td>  640X1136  </td>
<td>  750X1334 </td>
<td> 1080X1920(1.15)   </td>
</tr>
<tr>
<td> 屏幕大小    </td>
<td>   3.5&#8221;       </td>
<td> 3.5&#8221;      </td>
<td>  4.0&#8221;     </td>
<td>   4.7&#8221;    </td>
<td>  5.5&#8221;              </td>
</tr>
<tr>
<td> PPI        </td>
<td>   163        </td>
<td> 326       </td>
<td>  326      </td>
<td>   326     </td>
<td>  401              </td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby环境配置]]></title>
    <link href="http://viczy.github.io/blog/2014/11/09/rubyhuan-jing-pei-zhi/"/>
    <updated>2014-11-09T13:21:34+08:00</updated>
    <id>http://viczy.github.io/blog/2014/11/09/rubyhuan-jing-pei-zhi</id>
    <content type="html"><![CDATA[<!-- # ruby

![Ruby icon](http://learn-rails.com/images/ruby.png) -->


<h2>ruby安装</h2>

<p>ruby安装方式有下面几种</p>

<ul>
<li>原始码编译安装，下载相应版本的安装包安装（<a href="https://www.ruby-lang.org/zh_cn/downloads/">下载地址</a>）</li>
<li>第三方工具安装</li>
<li>少数的套件管理工具支持ruby</li>
</ul>


<p>考虑到多版本的管理，这里使用第二种方式（第三方工具）安装。第三方工具安装有RVM和Rbenv可选</p>

<h3>RVM</h3>

<p>rvm可以通过brew安装（<a href="http://brew.sh/index_zh-tw.html">brew的介绍与安装</a>），在安装前需要先安装装git版本控制</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brew install git
</span><span class='line'>$ brew install readline
</span><span class='line'>$ brew link readline</span></code></pre></td></tr></table></div></figure>


<p>然后安装rvm</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ \curl -L https://get.rvm.io | bash -s stable --ruby</span></code></pre></td></tr></table></div></figure>


<p>查看rvm的版本，来验证rvm是否已安装</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rvm -v</span></code></pre></td></tr></table></div></figure>


<p>当你的rvm不是最新版本，可以升级你的rvm版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rvm get stable</span></code></pre></td></tr></table></div></figure>


<p>接下来就可以通过rvm来安装ruby，下面将安装版本2.1.2的ruby，并将2.1.2版本作为当前预设版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rvm install 2.1.2
</span><span class='line'>$ rvm 2.1.2 --default</span></code></pre></td></tr></table></div></figure>


<p>查看ruby版本号，可以确认当前预设ruby的版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ruby -v</span></code></pre></td></tr></table></div></figure>


<p>如果还需要安装其他的版本的ruby，可以先查看可以安装的ruby版本，并选择你需要安装的版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rvm list known</span></code></pre></td></tr></table></div></figure>


<p>当安装了多个版本ruby后，查看已经安装了ruby</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rvm list</span></code></pre></td></tr></table></div></figure>


<p>这时如果你希望改变ruby的预设版本可以通过<code>rvm xxx -default</code> 来更新预设版本，这样的话每次打开个terminal窗口都会使用该版本的ruby。除了预设版本之外，如果你只在当前的terminal窗口使用某版本的ruby</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rvm use 1.9.3</span></code></pre></td></tr></table></div></figure>


<p>切换到系统内建的ruby版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rvm system</span></code></pre></td></tr></table></div></figure>


<h3>rbenv</h3>

<ul>
<li><a href="https://github.com/sstephenson/rbenv">rbenv</a></li>
<li><a href="https://ruby-china.org/wiki/rbenv-guide">rbenv使用</a></li>
</ul>


<h2>ruby使用</h2>

<h3>交互式运行Ruby</h3>

<p>要以交互式的运行ruby，只需要输入</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ruby</span></code></pre></td></tr></table></div></figure>


<p>然后输入你的ruby程序，以文件结束符结束（Ctrl+D）。</p>

<p>不多这样的方式操作比较麻烦，irb相对而言会是个更好地选择，irb是一个Ruby Shell。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ irb</span></code></pre></td></tr></table></div></figure>


<h3>运行Ruby程序文件</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ruby rubydemo.rb</span></code></pre></td></tr></table></div></figure>


<h3>Ruby查看文档</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ri puts</span></code></pre></td></tr></table></div></figure>


<h4>官方网站</h4>

<ul>
<li>中文<a href="https://www.ruby-lang.org/zh_tw/">https://www.ruby-lang.org/zh_tw/</a></li>
<li>英文<a href="https://www.ruby-lang.org/en/">https://www.ruby-lang.org/en/</a></li>
</ul>


<h4>Github</h4>

<p><a href="https://github.com/ruby/ruby">https://github.com/ruby/ruby</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ssh 免输入密码]]></title>
    <link href="http://viczy.github.io/blog/2014/08/27/title/"/>
    <updated>2014-08-27T22:39:56+08:00</updated>
    <id>http://viczy.github.io/blog/2014/08/27/title</id>
    <content type="html"><![CDATA[<!-- #ssh免输入 -->


<p>SSH(Secure Shell) 密钥对可以让您方便的登录到 SSH 服务器，而无需输入密码。由于您无需发送您的密码到网络中，SSH 密钥对被认为是更加安全的方式。再加上使用密码短语 (passphrase) 的使用，安全性会更上一层楼。</p>

<p>常见的密钥规则有RSA1，RSA2和DSA。</p>

<p>SSH 密钥对总是成双出现的，一把公钥，一把私钥。公钥可以自由的放在您所需要连接的 SSH 服务器上，而私钥必须稳妥的保管好。</p>

<p>所谓&#8221;公钥登录&#8221;，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录 shell，不再要求密码。这样子，我们即可保证了整个登录过程的安全，也不会受到中间人攻击。</p>

<h2>生成</h2>

<p>这里用RSA2生成密钥对。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ssh-keygen -t rsa </span></code></pre></td></tr></table></div></figure>


<pre><code>Generating public/private rsa key pair.

Enter file in which to save the key (/home/username/.ssh/id_rsa): [按 Enter 使用默认值（建议）]

Enter passphrase: 输入你的 Passphrase

Enter same passphrase again: 再一次输入你的 Passphrase

Your identification has been saved in /home/username/.ssh/id_rsa.

Your public key has been saved in /home/username/.ssh/id_rsa.pub.

The key fingerprint is: cc:e8:a9:da:a3:41:c6:a9:97:52:59:ef:0c:cf:45:b6 username@abc.com
</code></pre>

<p>上面的操作中你可以不输入Passphrase,按回车键可以跳过，这样的话下次你登陆服务器是不需要输入Passphrase。</p>

<h2>公钥放到服务器</h2>

<p>如果你使用了默认方式生成了密钥对</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ssh-copy-id remote-server.org</span></code></pre></td></tr></table></div></figure>


<p>指定密钥文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ssh-copy-id remote-server.org</span></code></pre></td></tr></table></div></figure>


<pre><code>指定远程服务器监听端口

```
$ ssh-copy-id -i ~/.ssh/id_rsa.pub username@remote-server.org
```

如果没有`ssh-copy-id`命令，请先安装

```
$ ssh-copy-id -i ~/.ssh/id_ecdsa.pub -p 221 username@remote-server.org
```
</code></pre>

<p>服务器要支持openssh，如果不支持，先安装（以下命令在服务器运行。以下是ubuntu服务器）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>~$ sudo apt-get install openssh-server </span></code></pre></td></tr></table></div></figure>


<p>如果生成过程中有输入Passphrase，那么会每次登陆远程服务器还要输入passphrase，这样太麻烦了，那么你还可能需要使用<code>ssh-agent</code>。这里就不做详细介绍了，请参照<a href="http://josephj.com/article/understand-ssh-key/">此文章</a></p>

<h2>登陆到服务器</h2>

<h4>参考资料</h4>

<ul>
<li><a href="https://wiki.archlinux.org/index.php/SSH_Keys_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">https://wiki.archlinux.org/index.php/SSH_Keys_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></li>
<li><a href="http://josephj.com/article/understand-ssh-key/">http://josephj.com/article/understand-ssh-key/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Start]]></title>
    <link href="http://viczy.github.io/blog/2014/04/05/start/"/>
    <updated>2014-04-05T18:05:30+08:00</updated>
    <id>http://viczy.github.io/blog/2014/04/05/start</id>
    <content type="html"><![CDATA[<p>The Blog Start</p>
]]></content>
  </entry>
  
</feed>
